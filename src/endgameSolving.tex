\chapter{Endgame Solving}
\label{ch:endgame-solving}
\epigraph{
  Poker has the only river in the world you can drown in more than once.
}{an~old Poker joke}
\vskip -2em
\note{
  This chapter summarizes the approach, methods and results of~the authors \cite{GanzfriedSandholm13improving}.
}

\section{Motivation}
\epigraphLong{
  Memorizing a~playbook is like memorizing a~script.
  When they change the script at the last minute it's like changing a~play in~a~game.
}{Michael Strahan}
Two-player zero-sum imperfect-information games can be solved via linear programming (\cite{Koller1994fast}), by modelling sequences of~moves as variables of~a~sequence-form \acrshort{lp} (recall Section~\ref{sec:solving-games-lp}).
This approach scales well to games with up to $10^8$ game states.
Unfortunately, many attractive Poker games are far larger~(\cite{Johanson2013measuring}):
\begin{itemize}
  \item two-player \acrfull{lhe} $\approx 10^{17}$ states
  \item two-player \acrfull{nlhe}\footnotemark{} $\approx 10^{165}$ states.
    \footnotetext{the most popular online variant of~Poker}
\end{itemize}
It is possible to find approximate equilibrium with iterative algorithms, as well.
These methods are guaranteed to converge in~the limit, and scale to~at least $10^{12}$ states (\cite{Hoda2010smoothing}; \cite{Zinkevich2007regret}).
Nevertheless, that is still not enough for the mentioned big poker variants.

Today, a~prevailing approach to enormous imperfect-information games (such as \acrshort{lhe} or \acrshort{nlhe}) is to reduce their sizes by~means of~\emph{abstractions}:
\begin{description}
  \item [Information abstraction] groups together different signals (e.g. similar poker hands).
  \item [Action abstraction] discretizes an~immense action space, making it thus smaller and more manageable.
\end{description}
The method afterwards finds an~\emph{approximate equilibrium} in the abstracted game.

An~appealing idea to diminish harmful effects of~the abstraction and the approximate-equilibrium search, is to~solve endgames dynamically:
an~agent only needs to~deal with those portions of~the game that are actually reached during a~play.
As a~consequence, the endgame can be re-solved with a~finer abstraction and more precise pot and stack sizes.

\section{Gadget Game}
We start by~constructing a~fine-grained subgame abstraction.
The original strategies for the subgame are discarded and only the strategies prior to the subgame (i.e. the trunk) are needed.
The strategies in the trunk are used to compute the joint distribution (i.e. belief) over the states at~the beginning of the subgame.

Finally, we add a~chance node~$c$ just before the fine-grained subgame~$S$.
The node leads to the states at~the root of~the subgame.
The chance node plays according to the computed belief.
Adding the chance node ``roots'' the subgame, thus making it a~well-defined game (Figure~\ref{fig:endgame-solving-gadget}).
\begin{figure}[H]
  \centering
  \includegraphics[width=.3\textwidth]{../img/endgame-solving-gadget.png}
  \caption{A~gadget game for endgame solving}
  \label{fig:endgame-solving-gadget}
\end{figure}

\section{Equivalent Linear Program}
\todo

The equivalent \acrshort{lp} formulation for the abstracted endgame is the sequence-form \acrshort{lp} from~(\ref{lp:seq-form}):
\begin{equation*}
  \begin{split}
    \max_{v, x}\  f^\top v & \\
    Ex &= e \\
    F^\top v - A^\top x &\le \vect{0} \\
    x &\ge \vect{0},
  \end{split}
\end{equation*}

\section{Experimental Results}
