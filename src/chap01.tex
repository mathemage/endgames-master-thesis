\chapter{Endgames: Perfect Situation in~Perfect-Information Games}

For many games, solving their late stages (so-called \emph{endgames}) can be done in~an~online way.
In other words, we are often able to postpone the computation of~the endgame strategy until the endgame itself is reached in~the play.

This is especially the case of~perfect-information games such as chess or Go, where the endgame technique has been used for long time.
In these domains, online endgame solving has~significant importance, as it substantially improves the playing quality of~agents.

\section{Chess Endgames}
\todo

\section{Go Endgames}
\todo

\subsection{Why Focus on Go Endgames?}

Martin~\Mueller (in~his dissertation~\cite{Muller1995computer}) mentions the following advantages of~Go endgames for research:
\begin{itemize}
  \item The complexity of~the game often decreases towards the end.
    This allows the study of~Go in a~controlled, simplified context.
  \item An~exact solution is possible for some classes of~endgame positions.
  \item The exact solution of~parts of~a~Go board facilitates the analysis of the rest.
    Reaching the ultimate goal of~winning the game is easier when complete information about part of~the game is at~hand.
    Such information is useful as~additional input for the heuristics that deal with the rest of~the board.

    Human experts use similar reasoning: they observe the score continually from the early midgame, and base their strategic decisions on~such an~analysis (\cite{Takagawa85}).
  \item Some methods developed for partitioning, searching and scoring during endgame carry over to the midgame and opening.
    As programs improve, fewer game-deciding blunders will occur, so the importance of~endgame-type calculation is bound to~increase.
  \item On~a~more philosophical note, the endgame relates to the full game of~Go similarly as Go relates to~real world AI problems.
    It provides a~simplified, more controlled sub-domain that allows the use of~stronger theoretical models than the larger, more general problem.
\end{itemize}

\subsection{Partitioning an~Endgame into Local (Sub)games}

According to~(\cite{Muller1995computer}), there are very strong reasons to~partition board positions during endgames in~Go:
\begin{quotation}
  A~Go position usually consists of~several local scenes that can be analyzed individually.
  In the opening, these scenes can be far apart, and their influence on~each other may be weak.
  A~better partition occurs late in the game, when there are walls of~stones dividing the board.
  A~move cannot have any influence across a~wall of~safe stones.

  \begin{figure}[H]
    \centering
    \includegraphics[width=.4\textwidth]{../img/late_endgame_Go_position_suited_for_exact_analysis.png}
    \caption{Late endgame position suited for exact analysis}
    \label{fig:late-Go-endgame}
  \end{figure}

  Board partition improves when many safe walls are on~the board.
  In the opening and midgame, any partition can be approximate at best.
  In the endgame, the partition gets more precise when the status of~all big groups has been settled, and the outlines of~territories are clear.
  When stones become ``immortal'', significant parts of~the board definitely belong to one of the players.
  The connected components of~the rest of~the board form local games that are independent from each other.

  If each local game is simple enough to~analyze completely (such as in Figure~\ref{fig:late-Go-endgame}), combinatorial game theory can compute an~optimal move for the full board position.
\end{quotation}

\subsection{Playing Computer Go as a~Sum of~Local Games}

This is the general procedure for playing Go as a~sum of~local games used in~(\cite{Muller1995computer}):
\begin{enumerate}
  \item Board partition: find safe blocks, safe territories, and local areas.
  \item Generate local game trees in each area.
  \item Evaluate local terminal positions.
  \item Transform local game trees into mathematical games (and simplify games).
  \item Find an optimal move in the sum game and play it.
\end{enumerate}
\Mueller proposes heuristic algorithms for playing the entire game, and exact algorithms for late endgame positions.
Thus, the task of~solving endgames in 1995---at the age of Computer Go's infancy---already played a~vital role.

\subsection{A~Combinatorial Game Theory Framework for Approximate Play of~Sum Games}

\Mueller also suggests to replace the ``standard model'' of~computer Go by a~sum game model.
The following benefits and problems of~the sum game model for computer Go are listed in~(\cite{Muller1995computer}):

\medskip

\underline{Benefits}
\begin{itemize}[+]
  \item The model is well suited to the knowledge and style of~\textit{(at that time)} current Go programs:
    they concentrate on local fighting and surrounding territories.
  \item Locality reduces the complexity of~move generation and position evaluation.
    With the emphasis on~evaluation, clever pruning during move generation is not as crucial as in~global search because of~the reduced search space.
  \item Stepwise, directed expansion of~search is supported.
    This provides more time control than the usual iterative deepening.
    It is easy to use opponent's time.
  \item Important Go terms can be expressed or~refined in terms of~the theory, and need not be programmed separately.
  \item The reuse of~local game analysis improves efficiency while playing a~game.
  \item Parallelism emerges naturally on~many levels: local searches are independent, evaluation and operations on mathematical games can be parallelized.
\end{itemize}

\underline{Problems}
\begin{itemize}[-]
  \item Managing incrementally changing sets of~local graphs in place of a single position adds complexity.
  \item Accurate board partition and recognition of~dependencies is crucial.
  \item The usual problems of~selective search appear in complicated local games:
    missing crucial moves leads to wrong evaluation.
  \item Non-constant local games may be overlooked completely, such as insecure ``territories'' which can be destroyed from the inside.
  \item In this model there is no concept of~long-range full board plans.
    This is probably not a~big issue until programs reach amateur Dan or even professional level \textit{(for an~update on the current situation, see Subsection~\ref{ssec:AlphaGo})}.
\end{itemize}

\subsection{A~Sum Game Model for the Entire Game of~Go}

Citing~(\cite{Muller1995computer}), there are several obstacles of~heuristic board partition (in the sum game model).

\begin{enumerate}[(a)]
  \item the impossibility of a~perfect, precise split:
    \begin{quotation}
      When applying a~local game model to the opening or~midgame, the biggest obstacle is the fact that the board cannot be partitioned into independent subgames.
      Few areas are completely surrounded, and surrounding stones are not yet invulnerable.
      We develop heuristics for board partition that split the imperfectly surrounded areas of~the opening and midgame.
    \end{quotation}

  \item the dependencies between the resulting subgames: 
    \begin{quotation}
      An~unavoidable side effect of~heuristic partition are dependencies between the resulting local games.
      Simple strategies for dealing with dependencies are pretending the games are independent, or re-searching a~bigger merged game.
    \end{quotation}
    See Section~\ref{ssec:dependencies-of-subgames} for more details.

  \item the difficulty (or almost infeasibility) of~exhaustive search in still quite large subgames:
    \begin{quotation}
      Even after heuristic partition, areas remain that are too big for an~exhaustive search by a~computer Go program, which must produce a~move in a~few seconds or minutes.
      In such big areas we use selective search.
      Tree growth is controlled by limiting the number of~moves generated, and by stopping the search before reaching a~terminal position.

      There are two levels of~search control:
      for the whole sum game, search time must be distributed between local games.
      For each local game, we must decide which nodes to expand and which expert modules to use for search and evaluation.
      A~post-processing stage handles detected dependencies between games.
    \end{quotation}
\end{enumerate}

Hence, the sum game model makes the best sense during the endgame part.
This general principle is as well applicable in poker:
we wait until the late stage of~the game, when it has greater impact to refine and re-solve the reached endgames.

\subsection{Dependencies Between Local Games}
\label{ssec:dependencies-of-subgames}

(\cite{Muller1995computer}) warns against the dangers of~subgame dependencies:

\begin{quotation}
  Dependencies between games occur when the areas of~local games overlap during area expansion, and when constraints of~one local game are related to~another game.
  The effect of~such dependencies differs widely:
  often it is so small that independence is a~useful approximation.
  In cases when a~move works as a~\emph{double threat} however, dependency analysis is crucial.
\end{quotation}

Strategies for dealing with dependencies are:
\begin{itemize}
  \item Ignore the dependency, treat games as independent
  \item Prove that the dependency does not affect the value of~the sum, or play of~the sum game
  \item Merge mutually dependent local games, then re-search the combined game, possibly using previously generated information on single games
  \item Analyze the interaction between local games, then use a~specialized theory to compute the joint game value
\end{itemize}

\subsection{Local Search and Evaluation in the Endgame}

Here is an overview of treating endgames in~(\cite{Muller1995computer}):
\begin{quotation}
  Following board partition, the algorithm for converting a Go endgame into a combinatorial game consists of generation of local game trees, scoring of local terminal positions, and evaluation of local games as mathematical games.
  Finally, a move in the resulting sum game must be selected, and identified with a move in the Go position.

  Safe territories and dame points are games that can be evaluated statically.
  Other local games are analyzed by local game tree search.
  Terminal positions are evaluated, and the values backed up in the tree, resulting in a mathematical game evaluation of each node.

  The result of search and analysis is a complete description of possible endgame plays that makes perfect play possible.
  We save the results of local analysis in a database of local positions.
  During play, each full board position corresponds one-to- one to a set of local positions, one from each local game.
  Positions and their values are retrieved from the database.

  The value of a full board position is the sum of local position values.
  A sum game evaluation algorithm selects a sufficiently good or optimal move.
  We also consider an algorithm with lower memory requirements, which stores only a subset of the positions of a local game in the database.
  In this case, if play reaches a position not stored in the database, we must re-search the corresponding local game.
\end{quotation}
In greater details, there are several points and aspects worth mentioning:
\begin{enumerate}[(a)]
  \item endgame area
    \begin{quotation}
      An~endgame area consists of~unsettled stones, and of~empty points not yet surrounded by~either color.
      Safe stones, usually of~both colors, surround the area.
      During endgame play, unsettled stones either become safe or are captured.
      Empty points will become occupied, safe territory or dame.
      A~rare case are ``untouchable'' empty points in \emph{seki}.

      \begin{figure}[H]
        \centering
        \includegraphics[width=.7\textwidth]{../img/Go_search_tree.png}
        \caption{Local game tree with evaluation of terminal nodes}
      \end{figure}
    \end{quotation}

  \item move generation
    \begin{quotation}
      We generate all legal moves for both colors, except in a~terminal position or if moves can be pruned.
      Examples of~\emph{pruning rules} are restricting the number of~\emph{dame} moves generated to at most one, and pruning moves dominated by other moves.%
      \footnote{Compare with \emph{policy networks} of~AlphaGo in Subsection~\ref{ssec:AlphaGo}}
      \emph{Termination rules} decide when a~position can be evaluated statically, without further expanding the tree.%
      \footnote{Compare with \emph{value network} of~AlphaGo in Subsection~\ref{ssec:AlphaGo}}
    \end{quotation}

  \item terminal positions
    \begin{quotation}
      \noindent
      We recognize the following terminal positions:
      \begin{itemize}
        \item[$\diamondsuit$] No legal moves
        \item[$\diamondsuit$] No good move (all points are territory, or dame)
        \item[$\diamondsuit$] Value of position known from transposition table, pattern, or local position database
      \end{itemize}
      The first two types of~terminal positions evaluate to a~number, or number-plus-star (odd
      number of~dame).
      If the value of a~position is known from another source, it is terminal in the sense that there is no need to continue search.
      The value itself can be any mathematical game value.
      Non-terminal positions may have a~constant value as well, if the outcome is the same no matter who plays first, but this has to be proven using search.
    \end{quotation}

  \item scoring
    \begin{quotation}
      Scoring assigns a~number, or number plus dame, to a~terminal position.
      In Chinese rules, scoring measures how many stones and empty points belong to either color.
      In Japanese rules, territory and prisoners are counted.
      Both kinds of~scoring are straightforward in the endgame because safe and dead stones, territories and neutral points are known exactly.
    \end{quotation}
\end{enumerate}

\subsection{AlphaGo}
\label{ssec:AlphaGo}
\todo
